<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GTFS Route Viewer</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    <style>
        #map {
            height: 100vh;
            width: 100%;
        }
        body {
            margin: 0;
            font-family: sans-serif;
        }
        input[type="file"] {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000; /* Ensure it's above the map */
            padding: 10px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <input type="file" id="gtfsFile" accept=".zip">
    <select id="stopSelector" style="position: absolute; top: 50px; left: 10px; z-index: 1000; padding: 5px; background: white; border: 1px solid #ccc; border-radius: 5px; max-width: 200px;">
        <option value="">-- Select a Stop to Filter Routes --</option>
    </select>
    <div id="map"></div>
    <div id="loadingPopup" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px; background: rgba(0,0,0,0.8); color: white; border-radius: 10px; z-index: 2000; font-size: 1.2em; box-shadow: 0 0 15px rgba(0,0,0,0.5);">
        Loading GTFS data...
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>
    <!-- JSZip JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"
     integrity="sha512-XMVd28F1oH/O71fzwBnV7HucLxVwtxf26XV8P4wPk26EDxuGZ91N8bsOttmnomcCD3CS5ZMRL50H0GgOHvegtg=="
     crossorigin="anonymous"></script>
    <!-- PapaParse JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"
     integrity="sha512-dfX5uYVXzyU8+KHqj8bjo7UkOdg18PaOtpa48djpNbZHwExddghZ+ZmzWT06R5v6NSk3ZUfsH6FNEDepLx9hPQ=="
     crossorigin="anonymous"></script>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize Leaflet map
        const map = L.map('map').setView([51.505, -0.09], 13); // Centered on London

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);

        // File input handling
        const fileInput = document.getElementById('gtfsFile');
        const loadingPopup = document.getElementById('loadingPopup');

        fileInput.addEventListener('change', async function(event) {
            const file = event.target.files[0];
            if (!file) {
                console.log("No file selected.");
                return;
            }
            console.log("File selected:", file.name);
            loadingPopup.textContent = 'Loading and unzipping file...';
            loadingPopup.style.display = 'block'; // Show loading popup

            try {
                const zip = await JSZip.loadAsync(file);
                console.log("ZIP file loaded.");
                loadingPopup.textContent = 'Parsing GTFS data files...';

                const requiredFiles = ["routes.txt", "trips.txt", "shapes.txt", "stops.txt", "stop_times.txt"];
                const parsedData = {
                    routes: [],
                    trips: [],
                    shapes: [],
                    stops: [],
                    stopTimes: []
                };

                for (const fileName of requiredFiles) {
                    const fileKey = fileName.split('.')[0].replace('_', ''); // e.g., stop_times -> stopTimes
                    const fileInZip = zip.file(fileName);
                    if (fileInZip) {
                        console.log(`Processing ${fileName}...`);
                        const content = await fileInZip.async("string");
                        const result = Papa.parse(content, {
                            header: true,
                            skipEmptyLines: true,
                            dynamicTyping: true // Automatically convert numbers and booleans
                        });
                        parsedData[fileKey] = result.data; // Use fileKey here
                        console.log(`${fileName} parsed successfully. Found ${result.data.length} records.`);
                    } else {
                        console.warn(`${fileName} not found in the ZIP.`);
                        // parsedData[fileKey] is already initialized to []
                    }
                }

                console.log("Parsed GTFS Data:", parsedData);

                // Call processGtfsData with all parsed data
                const processedData = await processGtfsData(
                    parsedData.routes,
                    parsedData.trips,
                    parsedData.shapes,
                    parsedData.stops,
                    parsedData.stopTimes
                );
                // console.log("Processed GTFS Data (for GeoJSON):", processedData); // Will log routesGeoJson and stopsGeoJson
                loadingPopup.textContent = 'Processing data and building map layers...';

                // Store data for potential filtering and display
                if (processedData) {
                    fullRoutesGeoJson = processedData.routesGeoJson; // Store for reset
                    stopToRouteIdsData = processedData.stopToRouteIdsMap;
                    // Initial display of all routes and stops
                    displayGtfsDataOnMap(processedData.routesGeoJson, processedData.stopsGeoJson);
                    // Populate stop selector
                    populateStopSelector(processedData.stopsGeoJson);
                }


            } catch (error) {
                console.error("Error processing data or displaying on map:", error);
            } finally {
                loadingPopup.style.display = 'none'; // Hide loading popup
            }
        });

        async function processGtfsData(routes, trips, shapes, stops, stopTimes) { // Added stops, stopTimes
            console.log("Processing GTFS data...");
            // console.log("Received stops for processing:", stops);
            // console.log("Received stopTimes for processing:", stopTimes);

            // Process Stops into GeoJSON Points
            const stopsGeoJsonFeatures = [];
            if (stops && stops.length > 0) {
                stops.forEach(stop => {
                    if (stop.stop_id && stop.stop_name && stop.stop_lon != null && stop.stop_lat != null) {
                        stopsGeoJsonFeatures.push({
                            type: "Feature",
                            geometry: {
                                type: "Point",
                                coordinates: [parseFloat(stop.stop_lon), parseFloat(stop.stop_lat)]
                            },
                            properties: {
                                stop_id: stop.stop_id,
                                stop_name: stop.stop_name,
                                stop_code: stop.stop_code,
                                stop_desc: stop.stop_desc,
                                zone_id: stop.zone_id,
                                stop_url: stop.stop_url,
                                location_type: stop.location_type,
                                parent_station: stop.parent_station,
                                wheelchair_boarding: stop.wheelchair_boarding
                                // Add other relevant stop properties if needed
                            }
                        });
                    } else {
                        // console.warn("Skipping stop with missing critical data (id, name, lon, or lat):", stop);
                    }
                });
            }
            const stopsGeoJson = { type: "FeatureCollection", features: stopsGeoJsonFeatures };
            console.log("Stops GeoJSON created:", stopsGeoJson);

            // Create Stop-Route Linkages (Part 4.2 Step 4)
            const stopToRouteIdsMap = {};
            const tripToRouteMap = {}; // Helper to quickly get route_id from trip_id

            if (trips && trips.length > 0) {
                trips.forEach(trip => {
                    if (trip.trip_id && trip.route_id) {
                        tripToRouteMap[trip.trip_id] = trip.route_id;
                    }
                });
            }

            if (stopTimes && stopTimes.length > 0) {
                stopTimes.forEach(stopTime => {
                    if (stopTime.trip_id && stopTime.stop_id) {
                        const routeId = tripToRouteMap[stopTime.trip_id];
                        if (routeId) {
                            if (!stopToRouteIdsMap[stopTime.stop_id]) {
                                stopToRouteIdsMap[stopTime.stop_id] = new Set(); // Use a Set to avoid duplicate route_ids
                            }
                            stopToRouteIdsMap[stopTime.stop_id].add(routeId);
                        }
                    }
                });
            }
            // Convert Sets to Arrays for easier use later, if needed, or keep as Sets
            for (const stopId in stopToRouteIdsMap) {
                stopToRouteIdsMap[stopId] = Array.from(stopToRouteIdsMap[stopId]);
            }
            console.log("Stop to Route IDs Map:", stopToRouteIdsMap);


            // Existing: 2. Group Shape Points
            const shapeGeometries = {};
            if (shapes && shapes.length > 0) {
                shapes.forEach(point => {
                    if (!point.shape_id || point.shape_pt_lon == null || point.shape_pt_lat == null || point.shape_pt_sequence == null) {
                        // console.warn("Skipping shape point with missing critical data:", point);
                        return;
                    }
                    if (!shapeGeometries[point.shape_id]) {
                        shapeGeometries[point.shape_id] = [];
                    }
                    // GeoJSON uses [lon, lat]
                    shapeGeometries[point.shape_id].push({
                        lon: parseFloat(point.shape_pt_lon),
                        lat: parseFloat(point.shape_pt_lat),
                        seq: parseInt(point.shape_pt_sequence, 10)
                    });
                });

                // Sort points within each shape by sequence
                for (const shapeId in shapeGeometries) {
                    shapeGeometries[shapeId].sort((a, b) => a.seq - b.seq);
                    // Now transform to just the coordinates array
                    shapeGeometries[shapeId] = shapeGeometries[shapeId].map(p => [p.lon, p.lat]);
                }
            }
            console.log("Shape geometries grouped and sorted:", shapeGeometries);

            // 3. Map Routes to Shapes
            const routeToShapeMap = {};
            if (trips && trips.length > 0) {
                trips.forEach(trip => {
                    if (trip.route_id && trip.shape_id) {
                        routeToShapeMap[trip.route_id] = trip.shape_id;
                    }
                });
            }
            console.log("Route to Shape Map:", routeToShapeMap);

            // 4. Build the GeoJSON Features
            const geojsonFeatures = [];
            if (routes && routes.length > 0) {
                routes.forEach(route => {
                    const shapeId = routeToShapeMap[route.route_id];
                    if (shapeId) {
                        const coordinates = shapeGeometries[shapeId];
                        if (coordinates && coordinates.length > 1) { // A LineString needs at least two points
                            const feature = {
                                type: "Feature",
                                geometry: {
                                    type: "LineString",
                                    coordinates: coordinates
                                },
                                properties: {
                                    route_id: route.route_id,
                                    route_short_name: route.route_short_name,
                                    route_long_name: route.route_long_name,
                                    route_desc: route.route_desc,
                                    route_type: route.route_type,
                                    route_url: route.route_url,
                                    route_color: route.route_color ? '#' + route.route_color : null, // Ensure # prefix for color
                                    route_text_color: route.route_text_color ? '#' + route.route_text_color : null // Ensure # prefix
                                }
                            };
                            geojsonFeatures.push(feature);
                        } else {
                            // console.warn(`Shape ${shapeId} for route ${route.route_id} has insufficient points.`);
                        }
                    } else {
                        // console.warn(`No shape_id found for route ${route.route_id}.`);
                    }
                });
            }
            console.log("GeoJSON features built:", geojsonFeatures);
            const routesGeoJson = { type: "FeatureCollection", features: geojsonFeatures };

            // 5. Return the Final Object(s)
            return {
                routesGeoJson: routesGeoJson,
                stopsGeoJson: stopsGeoJson, // Include stopsGeoJson created earlier
                stopToRouteIdsMap: stopToRouteIdsMap // Make this available
            };
        }

        let currentRoutesLayer = null;
        let currentStopsLayer = null;
        let fullRoutesGeoJson = null; // To store the unfiltered routes
        let stopToRouteIdsData = null; // To store the map for filtering

        function populateStopSelector(stopsGeoJson) {
            const selector = document.getElementById('stopSelector');
            // Clear existing options except the first one
            while (selector.options.length > 1) {
                selector.remove(1);
            }

            if (stopsGeoJson && stopsGeoJson.features) {
                // Sort stops by name for easier selection
                const sortedStops = [...stopsGeoJson.features].sort((a, b) => {
                    const nameA = a.properties.stop_name.toLowerCase();
                    const nameB = b.properties.stop_name.toLowerCase();
                    if (nameA < nameB) return -1;
                    if (nameA > nameB) return 1;
                    return 0;
                });

                sortedStops.forEach(feature => {
                    if (feature.properties && feature.properties.stop_id && feature.properties.stop_name) {
                        const option = document.createElement('option');
                        option.value = feature.properties.stop_id;
                        option.textContent = feature.properties.stop_name;
                        selector.appendChild(option);
                    }
                });
            }
        }

        // Event listener for stop selector
        document.getElementById('stopSelector').addEventListener('change', function(event) {
            const selectedStopId = event.target.value;

            if (!fullRoutesGeoJson || !stopToRouteIdsData) {
                console.warn("Data not fully loaded yet for filtering.");
                return;
            }

            if (selectedStopId) {
                const routeIdsForStop = stopToRouteIdsData[selectedStopId];
                if (routeIdsForStop && routeIdsForStop.length > 0) {
                    const filteredFeatures = fullRoutesGeoJson.features.filter(feature =>
                        routeIdsForStop.includes(feature.properties.route_id)
                    );
                    const filteredRoutes = { type: "FeatureCollection", features: filteredFeatures };
                    displayGtfsDataOnMap(filteredRoutes, null); // Display filtered routes, don't re-process stopsGeoJson here
                                                              // We might want to pass the original stopsGeoJson if we want to highlight the selected stop
                } else {
                    console.log(`No routes found for stop ${selectedStopId}. Displaying no routes.`);
                    displayGtfsDataOnMap({ type: "FeatureCollection", features: [] }, null); // Display no routes
                }
            } else {
                // No stop selected (or "-- Select --" chosen), display all routes
                displayGtfsDataOnMap(fullRoutesGeoJson, null); // Display all routes
            }
        });

        function displayGtfsDataOnMap(routesGeoJson, stopsGeoJson) {
            console.log("Displaying GTFS data on map...");

            // Clear Old Route Data
            if (currentRoutesLayer) {
                map.removeLayer(currentRoutesLayer);
                currentRoutesLayer = null;
            }

            // Only clear and re-add stops if stopsGeoJson is provided (i.e., initial load)
            if (stopsGeoJson !== undefined && stopsGeoJson !== null) { // Check specifically for undefined/null
                if (currentStopsLayer) {
                    map.removeLayer(currentStopsLayer);
                    currentStopsLayer = null;
                }
            }

            // Styling for Routes
            function routeStyle(feature) {
                return {
                    color: feature.properties.route_color || '#808080', // Default to grey if no color
                    weight: 5,
                    opacity: 0.75
                };
            }

            // 4. Implement onEachFeature Function for Popups
            function onEachRouteFeature(feature, layer) {
                if (feature.properties) {
                    let popupContent = `<strong>Route: ${feature.properties.route_short_name || 'N/A'}</strong>`;
                    if (feature.properties.route_long_name) {
                        popupContent += `<br>${feature.properties.route_long_name}`;
                    }
                    if (feature.properties.route_desc) {
                        popupContent += `<br><em>${feature.properties.route_desc}</em>`;
                    }
                     if (feature.properties.route_id) {
                        popupContent += `<br><small>ID: ${feature.properties.route_id}</small>`;
                    }
                    layer.bindPopup(popupContent);
                }
            }

            // Create and Add Routes Layer
            if (routesGeoJson && routesGeoJson.features && routesGeoJson.features.length > 0) {
                currentRoutesLayer = L.geoJSON(routesGeoJson, {
                    style: routeStyle,
                    onEachFeature: onEachRouteFeature
                }).addTo(map);
            } else {
                console.log("No route features to display on map.");
            }

            // Create and Add Stops Layer (only if stopsGeoJson is provided)
            if (stopsGeoJson && stopsGeoJson.features && stopsGeoJson.features.length > 0) {
                currentStopsLayer = L.geoJSON(stopsGeoJson, {
                    pointToLayer: function (feature, latlng) {
                        return L.circleMarker(latlng, {
                            radius: 5,
                            fillColor: "pink",
                            color: "#000",
                            weight: 1,
                            opacity: 1,
                            fillOpacity: 0.8
                        });
                    },
                    onEachFeature: function (feature, layer) { // Popup for stops
                        if (feature.properties && feature.properties.stop_name) {
                            layer.bindPopup(`<strong>Stop: ${feature.properties.stop_name}</strong><br><small>ID: ${feature.properties.stop_id}</small>`);
                        }
                    }
                }).addTo(map);
            } else {
                console.log("No stop features to display on map.");
            }

            // Fit Map to Bounds
            let boundsToFit = null;
            if (routesGeoJson && routesGeoJson.features && routesGeoJson.features.length > 0) {
                // If there are routes, get their bounds
                const tempRoutesLayer = L.geoJSON(routesGeoJson);
                boundsToFit = tempRoutesLayer.getBounds();
            }

            if (stopsGeoJson && stopsGeoJson.features && stopsGeoJson.features.length > 0) {
                // If stops are also being loaded/updated, extend bounds to include them
                const tempStopsLayer = L.geoJSON(stopsGeoJson);
                if (boundsToFit) {
                    boundsToFit.extend(tempStopsLayer.getBounds());
                } else {
                    boundsToFit = tempStopsLayer.getBounds();
                }
            }

            if (boundsToFit && boundsToFit.isValid()) {
                map.fitBounds(boundsToFit);
            } else if (routesGeoJson && routesGeoJson.features && routesGeoJson.features.length === 0) {
                // If routes are explicitly empty (e.g. after filtering, no routes for a stop),
                // do nothing with bounds, map stays as is. Or potentially reset to a default view.
                // For now, doing nothing is fine.
                console.log("No routes to fit bounds to, map view unchanged.");
            } else if (!boundsToFit) {
                 console.log("No features to calculate bounds from.");
            } else if (boundsToFit && !boundsToFit.isValid()){
                 console.warn("Could not fit map to bounds: calculated bounds are invalid.");
            }
        }
    });
    </script>
</body>
</html>
