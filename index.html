<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GTFS Route Viewer</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    <style>
        #map {
            height: 100vh;
            width: 100%;
        }
        body {
            margin: 0;
            font-family: sans-serif;
        }
        input[type="file"] {
            position: absolute;
            top: 10px;
            left: 55px; /* Changed from 10px */
            z-index: 1000; /* Ensure it's above the map */
            padding: 10px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <input type="file" id="gtfsFile" accept=".zip">
    <select id="stopSelector" style="position: absolute; top: 60px; left: 55px; z-index: 1000; padding: 5px; background: white; border: 1px solid #ccc; border-radius: 5px; max-width: 200px;">
        <option value="">-- Select a Stop to Filter Routes --</option>
    </select>
    <div id="map"></div>
    <div id="loadingPopup" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px; background: rgba(0,0,0,0.8); color: white; border-radius: 10px; z-index: 2000; font-size: 1.2em; box-shadow: 0 0 15px rgba(0,0,0,0.5);">
        Loading GTFS data...
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>
    <!-- JSZip JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"
     integrity="sha512-XMVd28F1oH/O71fzwBnV7HucLxVwtxf26XV8P4wPk26EDxuGZ91N8bsOttmnomcCD3CS5ZMRL50H0GgOHvegtg=="
     crossorigin="anonymous"></script>
    <!-- PapaParse JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"
     integrity="sha512-dfX5uYVXzyU8+KHqj8bjo7UkOdg18PaOtpa48djpNbZHwExddghZ+ZmzWT06R5v6NSk3ZUfsH6FNEDepLx9hPQ=="
     crossorigin="anonymous"></script>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize Leaflet map
        const map = L.map('map').setView([51.505, -0.09], 13); // Centered on London

        // Create custom panes for layer ordering
        map.createPane('routePane');
        map.getPane('routePane').style.zIndex = 640;
        map.createPane('stopPane');
        map.getPane('stopPane').style.zIndex = 650; // Higher zIndex means on top

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);

        map.on('zoomend', function() {
            if (currentStopsLayer) {
                const currentZoom = map.getZoom();
                let newRadius = 5; // Standard size (default for zoom < 13)
                if (currentZoom >= 13) {
                    newRadius = 3; // Smaller size for zoom >= 13
                }
                currentStopsLayer.eachLayer(function(layer) {
                    if (layer.setRadius) { // Check if it's a circleMarker
                        layer.setRadius(newRadius);
                    }
                });
            }
        });

        // File input handling
        const fileInput = document.getElementById('gtfsFile');
        const loadingPopup = document.getElementById('loadingPopup');

        fileInput.addEventListener('change', async function(event) {
            const file = event.target.files[0];
            if (!file) {
                console.log("No file selected.");
                return;
            }
            console.log("File selected:", file.name);
            loadingPopup.textContent = 'Loading and unzipping file...';
            loadingPopup.style.display = 'block';
            document.body.style.cursor = 'wait'; // Show wait cursor

            try {
                const zip = await JSZip.loadAsync(file);
                console.log("ZIP file loaded.");
                loadingPopup.textContent = 'Parsing GTFS data files...'; // General message before detailed loop

                const requiredFiles = ["routes.txt", "trips.txt", "shapes.txt", "stops.txt", "stop_times.txt"];
                const parsedData = {
                    routes: [],
                    trips: [],
                    shapes: [],
                    stops: [],
                    stopTimes: []
                };

                for (let i = 0; i < requiredFiles.length; i++) {
                    const fileName = requiredFiles[i];
                    let fileKey = fileName.split('.')[0]; // Get "routes", "trips", "shapes", "stops", "stop_times"
                    if (fileName === "stop_times.txt") {
                        fileKey = "stopTimes"; // Explicitly set to camelCase for stop_times
                    } else {
                        fileKey = fileKey.replace('_', ''); // Handle other potential cases like 'route_types' if added later
                    }
                    loadingPopup.textContent = `Parsing ${fileName} (${i + 1} of ${requiredFiles.length})...`;

                    const fileInZip = zip.file(fileName);
                    if (fileInZip) {
                        console.log(`Processing ${fileName}...`);
                        // Small delay to make text update visible, helpful for very fast parsing
                        // await new Promise(resolve => setTimeout(resolve, 50));
                        const content = await fileInZip.async("string");
                        const result = Papa.parse(content, {
                            header: true,
                            skipEmptyLines: true,
                            dynamicTyping: true // Automatically convert numbers and booleans
                        });
                        parsedData[fileKey] = result.data; // Use fileKey here
                        console.log(`${fileName} parsed successfully. Found ${result.data.length} records.`);
                    } else {
                        console.warn(`${fileName} not found in the ZIP.`);
                        // parsedData[fileKey] is already initialized to []
                    }
                }

                console.log("Parsed GTFS Data:", parsedData);

                // Call processGtfsData with all parsed data
                const processedData = await processGtfsData(
                    parsedData.routes,
                    parsedData.trips,
                    parsedData.shapes,
                    parsedData.stops,
                    parsedData.stopTimes
                );
                // console.log("Processed GTFS Data (for GeoJSON):", processedData); // Will log routesGeoJson and stopsGeoJson
                loadingPopup.textContent = 'Processing data and building map layers...';

                // Store data for potential filtering and display
                if (processedData) {
                    fullRoutesGeoJson = processedData.routesGeoJson; // Store for reset
                    stopToRouteIdsData = processedData.stopToRouteIdsMap;
                    // Initial display of all routes and stops
                    displayGtfsDataOnMap(processedData.routesGeoJson, processedData.stopsGeoJson);
                    // Populate stop selector
                    populateStopSelector(processedData.stopsGeoJson);
                }


            } catch (error) {
                console.error("Error processing data or displaying on map:", error);
            } finally {
                loadingPopup.style.display = 'none';
                document.body.style.cursor = 'default'; // Reset cursor
            }
        });

        async function processGtfsData(routes, trips, shapes, stops, stopTimes) { // Added stops, stopTimes
            console.log("Processing GTFS data...");
            // console.log("Received stops for processing:", stops);
            // console.log("Received stopTimes for processing:", stopTimes);

            // Process Stops into GeoJSON Points
            const stopsGeoJsonFeatures = [];
            if (stops && stops.length > 0) {
                stops.forEach(stop => {
                    if (stop.stop_id && stop.stop_name && stop.stop_lon != null && stop.stop_lat != null) {
                        stopsGeoJsonFeatures.push({
                            type: "Feature",
                            geometry: {
                                type: "Point",
                                coordinates: [parseFloat(stop.stop_lon), parseFloat(stop.stop_lat)]
                            },
                            properties: {
                                stop_id: stop.stop_id,
                                stop_name: stop.stop_name,
                                stop_code: stop.stop_code,
                                stop_desc: stop.stop_desc,
                                zone_id: stop.zone_id,
                                stop_url: stop.stop_url,
                                location_type: stop.location_type,
                                parent_station: stop.parent_station,
                                wheelchair_boarding: stop.wheelchair_boarding
                                // Add other relevant stop properties if needed
                            }
                        });
                    } else {
                        // console.warn("Skipping stop with missing critical data (id, name, lon, or lat):", stop);
                    }
                });
            }
            const stopsGeoJson = { type: "FeatureCollection", features: stopsGeoJsonFeatures };
            console.log("Stops GeoJSON created:", stopsGeoJson);

            // Create Stop-Route Linkages (Part 4.2 Step 4)
            console.log("Debug: Raw trips data sample (first 5):", trips ? trips.slice(0, 5) : "Trips data is undefined/null");
            console.log("Debug: Raw stopTimes data sample (first 5):", stopTimes ? stopTimes.slice(0, 5) : "StopTimes data is undefined/null");

            const stopToRouteIdsMap = {};
            const tripToRouteMap = {};

            if (trips && trips.length > 0) {
                trips.forEach(trip => {
                    if (trip && trip.trip_id && trip.route_id) {
                        // console.log(`Debug: Adding to tripToRouteMap: trip_id='${trip.trip_id}' (type: ${typeof trip.trip_id}), route_id='${trip.route_id}' (type: ${typeof trip.route_id})`);
                        tripToRouteMap[trip.trip_id] = trip.route_id;
                    } else {
                        // console.warn("Debug: Invalid trip object or missing trip_id/route_id in trips array:", trip);
                    }
                });
            }
            console.log("Debug: tripToRouteMap constructed:", tripToRouteMap);


            if (stopTimes && stopTimes.length > 0) {
                stopTimes.forEach(stopTime => {
                    if (stopTime && stopTime.trip_id && stopTime.stop_id) {
                        // console.log(`Debug: Processing stopTime: trip_id='${stopTime.trip_id}' (type: ${typeof stopTime.trip_id}), stop_id='${stopTime.stop_id}' (type: ${typeof stopTime.stop_id})`);
                        const routeId = tripToRouteMap[stopTime.trip_id];
                        // console.log(`Debug: For stopTime.trip_id '${stopTime.trip_id}', found routeId: '${routeId}' (type: ${typeof routeId})`);

                        if (routeId) {
                            if (!stopToRouteIdsMap[stopTime.stop_id]) {
                                // console.log(`Debug: Initializing Set for stop_id '${stopTime.stop_id}'`);
                                stopToRouteIdsMap[stopTime.stop_id] = new Set();
                            }
                            stopToRouteIdsMap[stopTime.stop_id].add(routeId);
                            // console.log(`Debug: Added route_id '${routeId}' to stop_id '${stopTime.stop_id}'. Current set for stop:`, stopToRouteIdsMap[stopTime.stop_id]);
                        } else {
                             console.warn(`Debug: No route_id found in tripToRouteMap for trip_id '${stopTime.trip_id}' (referenced by stop_time for stop_id '${stopTime.stop_id}').`);
                        }
                    } else {
                        // console.warn("Debug: Invalid stopTime object or missing trip_id/stop_id in stopTimes array:", stopTime);
                    }
                });
            }
            // Convert Sets to Arrays
            for (const stopId in stopToRouteIdsMap) {
                stopToRouteIdsMap[stopId] = Array.from(stopToRouteIdsMap[stopId]);
            }
            console.log("Stop to Route IDs Map (after processing):", stopToRouteIdsMap);
            // console.log("Debug: stopToRouteIdsMap final", JSON.parse(JSON.stringify(stopToRouteIdsMap)));


            // Existing: 2. Group Shape Points
            const shapeGeometries = {};
            if (shapes && shapes.length > 0) {
                shapes.forEach(point => {
                    if (!point.shape_id || point.shape_pt_lon == null || point.shape_pt_lat == null || point.shape_pt_sequence == null) {
                        // console.warn("Skipping shape point with missing critical data:", point);
                        return;
                    }
                    if (!shapeGeometries[point.shape_id]) {
                        shapeGeometries[point.shape_id] = [];
                    }
                    // GeoJSON uses [lon, lat]
                    shapeGeometries[point.shape_id].push({
                        lon: parseFloat(point.shape_pt_lon),
                        lat: parseFloat(point.shape_pt_lat),
                        seq: parseInt(point.shape_pt_sequence, 10)
                    });
                });

                // Sort points within each shape by sequence
                for (const shapeId in shapeGeometries) {
                    shapeGeometries[shapeId].sort((a, b) => a.seq - b.seq);
                    // Now transform to just the coordinates array
                    shapeGeometries[shapeId] = shapeGeometries[shapeId].map(p => [p.lon, p.lat]);
                }
            }
            console.log("Shape geometries grouped and sorted:", shapeGeometries);

            // 3. Map Routes to Shapes
            const routeToShapeMap = {};
            if (trips && trips.length > 0) {
                trips.forEach(trip => {
                    if (trip.route_id && trip.shape_id) {
                        routeToShapeMap[trip.route_id] = trip.shape_id;
                    }
                });
            }
            console.log("Route to Shape Map:", routeToShapeMap);

            // 4. Build the GeoJSON Features
            const geojsonFeatures = [];
            if (routes && routes.length > 0) {
                routes.forEach(route => {
                    const shapeId = routeToShapeMap[route.route_id];
                    if (shapeId) {
                        const coordinates = shapeGeometries[shapeId];
                        if (coordinates && coordinates.length > 1) { // A LineString needs at least two points
                            const feature = {
                                type: "Feature",
                                geometry: {
                                    type: "LineString",
                                    coordinates: coordinates
                                },
                                properties: {
                                    route_id: route.route_id,
                                    route_short_name: route.route_short_name,
                                    route_long_name: route.route_long_name,
                                    route_desc: route.route_desc,
                                    route_type: route.route_type,
                                    route_url: route.route_url,
                                    route_color: route.route_color ? '#' + route.route_color : null, // Ensure # prefix for color
                                    route_text_color: route.route_text_color ? '#' + route.route_text_color : null // Ensure # prefix
                                }
                            };
                            geojsonFeatures.push(feature);
                        } else {
                            // console.warn(`Shape ${shapeId} for route ${route.route_id} has insufficient points.`);
                        }
                    } else {
                        // console.warn(`No shape_id found for route ${route.route_id}.`);
                    }
                });
            }
            console.log("GeoJSON features built:", geojsonFeatures);
            const routesGeoJson = { type: "FeatureCollection", features: geojsonFeatures };

            // 5. Return the Final Object(s)
            return {
                routesGeoJson: routesGeoJson,
                stopsGeoJson: stopsGeoJson, // Include stopsGeoJson created earlier
                stopToRouteIdsMap: stopToRouteIdsMap // Make this available
            };
        }

        let currentRoutesLayer = null;
        let currentStopsLayer = null;
        let fullRoutesGeoJson = null; // To store the unfiltered routes
        let stopToRouteIdsData = null; // To store the map for filtering

        function populateStopSelector(stopsGeoJson) {
            const selector = document.getElementById('stopSelector');
            // Clear existing options except the first one
            while (selector.options.length > 1) {
                selector.remove(1);
            }

            if (stopsGeoJson && stopsGeoJson.features) {
                // Sort stops by name for easier selection
                const sortedStops = [...stopsGeoJson.features].sort((a, b) => {
                    const nameA = a.properties.stop_name.toLowerCase();
                    const nameB = b.properties.stop_name.toLowerCase();
                    if (nameA < nameB) return -1;
                    if (nameA > nameB) return 1;
                    return 0;
                });

                sortedStops.forEach(feature => {
                    if (feature.properties && feature.properties.stop_id && feature.properties.stop_name) {
                        const option = document.createElement('option');
                        option.value = feature.properties.stop_id;
                        option.textContent = feature.properties.stop_name;
                        selector.appendChild(option);
                    }
                });
            }
        }

        // Event listener for stop selector
        document.getElementById('stopSelector').addEventListener('change', function(event) {
            const selectedStopId = event.target.value;
            console.log(`Filtering by selectedStopId: '${selectedStopId}' (type: ${typeof selectedStopId})`);

            if (!fullRoutesGeoJson || !stopToRouteIdsData) {
                console.warn("Data not fully loaded yet for filtering (fullRoutesGeoJson or stopToRouteIdsData is missing).");
                return;
            }

            if (selectedStopId) {
                const routeIdsForStop = stopToRouteIdsData[selectedStopId];
                console.log(`Route IDs found for stop '${selectedStopId}':`, routeIdsForStop);

                if (routeIdsForStop && routeIdsForStop.length > 0) {
                    const filteredFeatures = fullRoutesGeoJson.features.filter(feature => {
                        const include = routeIdsForStop.includes(feature.properties.route_id);
                        // console.log(`Route ${feature.properties.route_id} included: ${include}`);
                        return include;
                    });
                    console.log("Filtered features:", filteredFeatures);
                    const filteredRoutes = { type: "FeatureCollection", features: filteredFeatures };
                    displayGtfsDataOnMap(filteredRoutes, null);
                } else {
                    console.log(`No routes found for stop '${selectedStopId}' in stopToRouteIdsData or list is empty. Displaying no routes.`);
                    displayGtfsDataOnMap({ type: "FeatureCollection", features: [] }, null);
                }
            } else {
                // No stop selected (or "-- Select --" chosen), display all routes
                console.log("No stop selected, displaying all routes.");
                displayGtfsDataOnMap(fullRoutesGeoJson, null); // Display all routes
            }
        });

        function displayGtfsDataOnMap(routesGeoJson, stopsGeoJson) {
            console.log("Displaying GTFS data on map...");

            // Clear Old Route Data
            if (currentRoutesLayer) {
                map.removeLayer(currentRoutesLayer);
                currentRoutesLayer = null;
            }

            // Only clear and re-add stops if stopsGeoJson is provided (i.e., initial load)
            if (stopsGeoJson !== undefined && stopsGeoJson !== null) { // Check specifically for undefined/null
                if (currentStopsLayer) {
                    map.removeLayer(currentStopsLayer);
                    currentStopsLayer = null;
                }
            }

            // Styling for Routes
            function routeStyle(feature) {
                return {
                    color: feature.properties.route_color || '#808080', // Default to grey if no color
                    weight: 5,
                    opacity: 0.75
                };
            }

            // 4. Implement onEachFeature Function for Popups
            function onEachRouteFeature(feature, layer) {
                if (feature.properties) {
                    let popupContent = `<strong>Route: ${feature.properties.route_short_name || 'N/A'}</strong>`;
                    if (feature.properties.route_long_name) {
                        popupContent += `<br>${feature.properties.route_long_name}`;
                    }
                    if (feature.properties.route_desc) {
                        popupContent += `<br><em>${feature.properties.route_desc}</em>`;
                    }
                     if (feature.properties.route_id) {
                        popupContent += `<br><small>ID: ${feature.properties.route_id}</small>`;
                    }
                    layer.bindPopup(popupContent);
                }
            }

            // Create and Add Routes Layer
            if (routesGeoJson && routesGeoJson.features && routesGeoJson.features.length > 0) {
                currentRoutesLayer = L.geoJSON(routesGeoJson, {
                    style: routeStyle,
                    onEachFeature: onEachRouteFeature,
                    pane: 'routePane' // Assign to routePane
                }).addTo(map);
            } else {
                console.log("No route features to display on map.");
            }

            // Create and Add Stops Layer (only if stopsGeoJson is provided)
            if (stopsGeoJson && stopsGeoJson.features && stopsGeoJson.features.length > 0) {
                currentStopsLayer = L.geoJSON(stopsGeoJson, {
                    pointToLayer: function (feature, latlng) {
                        const currentZoom = map.getZoom();
                        let radius = 5; // Standard size (default for zoom < 13)
                        if (currentZoom >= 13) {
                            radius = 3; // Smaller size for zoom >= 13
                        }
                        return L.circleMarker(latlng, {
                            radius: radius,
                            fillColor: "pink",
                            color: "#000",
                            weight: 1,
                            opacity: 1,
                            fillOpacity: 0.8,
                            pane: 'stopPane' // Assign to stopPane
                        });
                    },
                    onEachFeature: function (feature, layer) { // Popup for stops
                        if (feature.properties && feature.properties.stop_name) {
                            const lat = feature.geometry.coordinates[1];
                            const lon = feature.geometry.coordinates[0];
                            const stopId = feature.properties.stop_id;
                            layer.bindPopup(`<strong>Stop: ${feature.properties.stop_name}</strong><br><small>ID: ${stopId}</small><br><button onclick="handleFromHere('${stopId}', ${lat}, ${lon})">From here</button>`);
                        }
                    }
                }).addTo(map);
            } else {
                console.log("No stop features to display on map.");
            }

            // Fit Map to Bounds
            let boundsToFit = null;
            if (routesGeoJson && routesGeoJson.features && routesGeoJson.features.length > 0) {
                // If there are routes, get their bounds
                const tempRoutesLayer = L.geoJSON(routesGeoJson);
                boundsToFit = tempRoutesLayer.getBounds();
            }

            if (stopsGeoJson && stopsGeoJson.features && stopsGeoJson.features.length > 0) {
                // If stops are also being loaded/updated, extend bounds to include them
                const tempStopsLayer = L.geoJSON(stopsGeoJson);
                if (boundsToFit) {
                    boundsToFit.extend(tempStopsLayer.getBounds());
                } else {
                    boundsToFit = tempStopsLayer.getBounds();
                }
            }

            if (boundsToFit && boundsToFit.isValid()) {
                map.fitBounds(boundsToFit);
            } else if (routesGeoJson && routesGeoJson.features && routesGeoJson.features.length === 0) {
                // If routes are explicitly empty (e.g. after filtering, no routes for a stop),
                // do nothing with bounds, map stays as is. Or potentially reset to a default view.
                // For now, doing nothing is fine.
                console.log("No routes to fit bounds to, map view unchanged.");
            } else if (!boundsToFit) {
                 console.log("No features to calculate bounds from.");
            } else if (boundsToFit && !boundsToFit.isValid()){
                 console.warn("Could not fit map to bounds: calculated bounds are invalid.");
            }
        }
    });

    function handleFromHere(stopId, lat, lon) {
        console.log(`"From here" button clicked for Stop ID: ${stopId}, Lat: ${lat}, Lon: ${lon}`);

        const selector = document.getElementById('stopSelector');
        if (selector) {
            selector.value = stopId;

            // Create and dispatch a 'change' event
            const changeEvent = new Event('change', { bubbles: true });
            selector.dispatchEvent(changeEvent);
        } else {
            console.error("Stop selector not found.");
        }
    }
    </script>
</body>
</html>
