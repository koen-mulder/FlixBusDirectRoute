<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GTFS Route Viewer</title>
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    <style>
        #map {
            height: 100vh;
            width: 100%;
        }
        body {
            margin: 0;
            font-family: sans-serif;
        }
        input[type="file"] {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000; /* Ensure it's above the map */
            padding: 10px;
            background: white;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <input type="file" id="gtfsFile" accept=".zip">
    <div id="map"></div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>
    <!-- JSZip JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"
     integrity="sha512-XMVd28F1oH/O71fzwBnV7HucLxVwtxf26XV8P4wPk26EDxuGZ91N8bsOttmnomcCD3CS5ZMRL50H0GgOHvegtg=="
     crossorigin="anonymous"></script>
    <!-- PapaParse JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"
     integrity="sha512-dfX5uYVXzyU8+KHqj8bjo7UkOdg18PaOtpa48djpNbZHwExddghZ+ZmzWT06R5v6NSk3ZUfsH6FNEDepLx9hPQ=="
     crossorigin="anonymous"></script>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize Leaflet map
        const map = L.map('map').setView([51.505, -0.09], 13); // Centered on London

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 19,
            attribution: 'Â© OpenStreetMap contributors'
        }).addTo(map);

        // File input handling
        const fileInput = document.getElementById('gtfsFile');
        fileInput.addEventListener('change', async function(event) {
            const file = event.target.files[0];
            if (!file) {
                console.log("No file selected.");
                return;
            }
            console.log("File selected:", file.name);

            try {
                const zip = await JSZip.loadAsync(file);
                console.log("ZIP file loaded.");

                const requiredFiles = ["routes.txt", "trips.txt", "shapes.txt"];
                const parsedData = {};

                for (const fileName of requiredFiles) {
                    const fileInZip = zip.file(fileName);
                    if (fileInZip) {
                        console.log(`Processing ${fileName}...`);
                        const content = await fileInZip.async("string");
                        const result = Papa.parse(content, {
                            header: true,
                            skipEmptyLines: true,
                            dynamicTyping: true // Automatically convert numbers and booleans
                        });
                        parsedData[fileName.split('.')[0]] = result.data;
                        console.log(`${fileName} parsed successfully. Found ${result.data.length} records.`);
                    } else {
                        console.warn(`${fileName} not found in the ZIP.`);
                        parsedData[fileName.split('.')[0]] = []; // Ensure array exists even if file is missing
                    }
                }

                console.log("Parsed GTFS Data:", {
                    routes: parsedData.routes,
                    trips: parsedData.trips,
                    routes: parsedData.routes || [],
                    trips: parsedData.trips || [],
                    shapes: parsedData.shapes || []
                });

                // Call processGtfsData
                const geojsonData = await processGtfsData(parsedData.routes || [], parsedData.trips || [], parsedData.shapes || []);
                console.log("Final GeoJSON FeatureCollection:", geojsonData);

                // Display routes on map
                displayRoutesOnMap(geojsonData);

            } catch (error) {
                console.error("Error processing data or displaying on map:", error);
            }
        });

        async function processGtfsData(routes, trips, shapes) {
            console.log("Processing GTFS data into GeoJSON...");

            // 2. Group Shape Points
            const shapeGeometries = {};
            if (shapes && shapes.length > 0) {
                shapes.forEach(point => {
                    if (!point.shape_id || point.shape_pt_lon == null || point.shape_pt_lat == null || point.shape_pt_sequence == null) {
                        // console.warn("Skipping shape point with missing critical data:", point);
                        return;
                    }
                    if (!shapeGeometries[point.shape_id]) {
                        shapeGeometries[point.shape_id] = [];
                    }
                    // GeoJSON uses [lon, lat]
                    shapeGeometries[point.shape_id].push({
                        lon: parseFloat(point.shape_pt_lon),
                        lat: parseFloat(point.shape_pt_lat),
                        seq: parseInt(point.shape_pt_sequence, 10)
                    });
                });

                // Sort points within each shape by sequence
                for (const shapeId in shapeGeometries) {
                    shapeGeometries[shapeId].sort((a, b) => a.seq - b.seq);
                    // Now transform to just the coordinates array
                    shapeGeometries[shapeId] = shapeGeometries[shapeId].map(p => [p.lon, p.lat]);
                }
            }
            console.log("Shape geometries grouped and sorted:", shapeGeometries);

            // 3. Map Routes to Shapes
            const routeToShapeMap = {};
            if (trips && trips.length > 0) {
                trips.forEach(trip => {
                    if (trip.route_id && trip.shape_id) {
                        routeToShapeMap[trip.route_id] = trip.shape_id;
                    }
                });
            }
            console.log("Route to Shape Map:", routeToShapeMap);

            // 4. Build the GeoJSON Features
            const geojsonFeatures = [];
            if (routes && routes.length > 0) {
                routes.forEach(route => {
                    const shapeId = routeToShapeMap[route.route_id];
                    if (shapeId) {
                        const coordinates = shapeGeometries[shapeId];
                        if (coordinates && coordinates.length > 1) { // A LineString needs at least two points
                            const feature = {
                                type: "Feature",
                                geometry: {
                                    type: "LineString",
                                    coordinates: coordinates
                                },
                                properties: {
                                    route_id: route.route_id,
                                    route_short_name: route.route_short_name,
                                    route_long_name: route.route_long_name,
                                    route_desc: route.route_desc,
                                    route_type: route.route_type,
                                    route_url: route.route_url,
                                    route_color: route.route_color ? '#' + route.route_color : null, // Ensure # prefix for color
                                    route_text_color: route.route_text_color ? '#' + route.route_text_color : null // Ensure # prefix
                                }
                            };
                            geojsonFeatures.push(feature);
                        } else {
                            // console.warn(`Shape ${shapeId} for route ${route.route_id} has insufficient points.`);
                        }
                    } else {
                        // console.warn(`No shape_id found for route ${route.route_id}.`);
                    }
                });
            }
            console.log("GeoJSON features built:", geojsonFeatures);

            // 5. Return the Final Object
            return { type: "FeatureCollection", features: geojsonFeatures };
        }

        let currentGeoJsonLayer = null; // To keep track of the current routes layer

        function displayRoutesOnMap(geojson) {
            console.log("Displaying GeoJSON on map:", geojson);

            // 2. Clear Old Data
            if (currentGeoJsonLayer) {
                map.removeLayer(currentGeoJsonLayer);
                currentGeoJsonLayer = null;
            }

            // 3. Implement Styling Function
            function routeStyle(feature) {
                return {
                    color: feature.properties.route_color || '#808080', // Default to grey if no color
                    weight: 5,
                    opacity: 0.75
                };
            }

            // 4. Implement onEachFeature Function for Popups
            function onEachRouteFeature(feature, layer) {
                if (feature.properties) {
                    let popupContent = `<strong>Route: ${feature.properties.route_short_name || 'N/A'}</strong>`;
                    if (feature.properties.route_long_name) {
                        popupContent += `<br>${feature.properties.route_long_name}`;
                    }
                    if (feature.properties.route_desc) {
                        popupContent += `<br><em>${feature.properties.route_desc}</em>`;
                    }
                     if (feature.properties.route_id) {
                        popupContent += `<br><small>ID: ${feature.properties.route_id}</small>`;
                    }
                    layer.bindPopup(popupContent);
                }
            }

            // 5. Create and Add GeoJSON Layer
            if (geojson && geojson.features && geojson.features.length > 0) {
                currentGeoJsonLayer = L.geoJSON(geojson, {
                    style: routeStyle,
                    onEachFeature: onEachRouteFeature
                }).addTo(map);

                // 6. Fit Map to Bounds
                if (currentGeoJsonLayer && typeof currentGeoJsonLayer.getBounds === 'function') {
                    const bounds = currentGeoJsonLayer.getBounds();
                    if (bounds.isValid()) {
                        map.fitBounds(bounds);
                    } else {
                        console.warn("Could not fit map to bounds: bounds are invalid.");
                    }
                }
            } else {
                console.log("No features to display on map.");
            }
        }
    });
    </script>
</body>
</html>
